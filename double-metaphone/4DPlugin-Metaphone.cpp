/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Metaphone.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Metaphone
 #	author : miyako
 #	2022/03/14
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Metaphone.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Metaphone
            
			case 1 :
				DoubleMetaphone(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

using namespace std;

#define macroman_Ä 0x80
#define macroman_Å 0x81
#define macroman_Ç 0x82
#define macroman_É 0x83
#define macroman_Ñ 0x84
#define macroman_Ö 0x85
#define macroman_Ü 0x86
#define macroman_á 0x87
#define macroman_à 0x88
#define macroman_â 0x89
#define macroman_ä 0x8A
#define macroman_ã 0x8B
#define macroman_å 0x8C
#define macroman_ç 0x8D
#define macroman_é 0x8E
#define macroman_è 0x8F
#define macroman_ê 0x90
#define macroman_ë 0x91
#define macroman_í 0x92
#define macroman_ì 0x93
#define macroman_î 0x94
#define macroman_ï 0x95
#define macroman_ñ 0x96
#define macroman_ó 0x97
#define macroman_ò 0x98
#define macroman_ô 0x99
#define macroman_ö 0x9A
#define macroman_õ 0x9B
#define macroman_ú 0x9C
#define macroman_ù 0x9D
#define macroman_û 0x9E
#define macroman_ü 0x9F
#define macroman_Æ 0xAE
#define macroman_Ø 0xAF
#define macroman_æ 0xBE
#define macroman_ø 0xBF
#define macroman_À 0xCB
#define macroman_Ã 0xCC
#define macroman_Õ 0xCD
#define macroman_Œ 0xCE
#define macroman_œ 0xCF
#define macroman_ÿ 0xD8
#define macroman_Ÿ 0xD9
#define macroman_ﬁ 0xDE
#define macroman_ﬂ 0xDF
#define macroman_Â 0xE5
#define macroman_Ê 0xE6
#define macroman_Á 0xE7
#define macroman_Ë 0xE8
#define macroman_È 0xE9
#define macroman_Í 0xEA
#define macroman_Î 0xEB
#define macroman_Ï 0xEC
#define macroman_Ì 0xED
#define macroman_Ó 0xEE
#define macroman_Ô 0xEF
#define macroman_Ò 0xF1
#define macroman_Ú 0xF2
#define macroman_Û 0xF3
#define macroman_Ù 0xF4

const unsigned int max_length = 999;

static void MakeUpper(string &s) {
  for (unsigned int i = 0; i < s.length(); i++) {
      switch (s[i]) {
          case macroman_á:
              s[i] = macroman_Á;
              break;
          case macroman_à:
              s[i] = macroman_À;
              break;
          case macroman_â:
              s[i] = macroman_Â;
              break;
          case macroman_ä:
              s[i] = macroman_Ä;
              break;
          case macroman_ã:
              s[i] = macroman_Ã;
              break;
          case macroman_å:
              s[i] = macroman_Å;
              break;
          case macroman_é:
              s[i] = macroman_É;
              break;
          case macroman_è:
              s[i] = macroman_È;
              break;
          case macroman_ê:
              s[i] = macroman_Ê;
              break;
          case macroman_ë:
              s[i] = macroman_Ë;
              break;
          case macroman_í:
              s[i] = macroman_Í;
              break;
          case macroman_ì:
              s[i] = macroman_Ì;
              break;
          case macroman_î:
              s[i] = macroman_Î;
              break;
          case macroman_ï:
              s[i] = macroman_Ï;
              break;
          case macroman_ó:
              s[i] = macroman_Ó;
              break;
          case macroman_ò:
              s[i] = macroman_Ò;
              break;
          case macroman_ô:
              s[i] = macroman_Ô;
              break;
          case macroman_ö:
              s[i] = macroman_Ö;
              break;
          case macroman_õ:
              s[i] = macroman_Õ;
              break;
          case macroman_ú:
              s[i] = macroman_Ú;
              break;
          case macroman_ù:
              s[i] = macroman_Ù;
              break;
          case macroman_û:
              s[i] = macroman_Û;
              break;
          case macroman_ü:
              s[i] = macroman_Ü;
              break;
          case macroman_ç:
              s[i] = macroman_Ç;
              break;
          case macroman_æ:
              s[i] = macroman_Æ;
              break;
          case macroman_ø:
              s[i] = macroman_Ø;
              break;
          case macroman_œ:
              s[i] = macroman_Œ;
              break;
          case macroman_ÿ:
              s[i] = macroman_Ÿ;
              break;
          case macroman_ﬁ:
              s[i] = macroman_ﬂ;
              break;
          case macroman_ñ:
              s[i] = macroman_Ñ;
              break;
              
          default:
              s[i] = toupper(s[i]);
              break;
      }
  }
}

static int IsVowel(string &s, unsigned int pos)
{
  char c;

  if ((pos < 0) || (pos >= s.length()))
    return 0;

  c = s[pos];
  if ((c == 'A') || (c == 'E') || (c == 'I') || (c =='O') ||
      (c =='U')  || (c == 'Y')) {
    return 1;
  }

  return 0;
}

static int SlavoGermanic(string &s)
{
  if ((char *) strstr(s.c_str(), "W"))
    return 1;
  else if ((char *) strstr(s.c_str(), "K"))
    return 1;
  else if ((char *) strstr(s.c_str(), "CZ"))
    return 1;
  else if ((char *) strstr(s.c_str(), "WITZ"))
    return 1;
  else
    return 0;
}

static char GetAt(string &s, unsigned int pos)
{
  if ((pos < 0) || (pos >= s.length())) {
    return '\0';
  }

  return s[pos];
}

static void SetAt(string &s, unsigned int pos, char c)
{
  if ((pos < 0) || (pos >= s.length())) {
    return;
  }

  s[pos] = c;
}

/*
  Caveats: the START value is 0 based
*/

static int StringAt(string &s, unsigned int start, unsigned int length, ...)
{
  char *test;
  const char *pos;
  va_list ap;

  if ((start < 0) || (start >= s.length())) {
    return 0;
  }

  pos = (s.c_str() + start);
  va_start(ap, length);

  do {
    test = va_arg(ap, char *);
    if (*test && (strncmp(pos, test, length) == 0)) {
      return 1;
    }
  } while (strcmp(test, ""));

  va_end(ap);

  return 0;
}

static void push_back(PA_CollectionRef metaphones, std::string& str)
{
    uint32_t len = (uint32_t)(str.length() * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
    std::vector<uint8_t> buf(len);
    
    PA_ConvertCharsetToCharset(
                               (char *)str.c_str(),
                               str.length() * sizeof(char),
                               eVTC_MAC_ROMAN,
                               (char *)&buf[0],
                               len,
                               eVTC_UTF_16
                               );
    
    PA_Variable v = PA_CreateVariable(eVK_Unistring);
    PA_Unistring value = PA_CreateUnistring((PA_Unichar *)&buf[0]);
    PA_SetStringVariable(&v, &value);
    PA_SetCollectionElement(metaphones, PA_GetCollectionLength(metaphones), v);
    PA_ClearVariable(&v);
}

static void DoubleMetaphoneImplementation(string &str, PA_CollectionRef codes)
{
  int        length;
  string original;
  string primary;
  string secondary;
  int        current;
  int        last;

  current = 0;
  /* we need the real length and last prior to padding */
  length  = str.length();
  last    = length - 1;
  original = str; // make a copy
  /* Pad original so we can index beyond end */
  original += "     ";

  primary = "";
  secondary = "";

  MakeUpper(original);

  /* skip these when at start of word */
  if (StringAt(original, 0, 2, "GN", "KN", "PN", "WR", "PS", "")) {
    current += 1;
  }

  /* Initial 'X' is pronounced 'Z' e.g. 'Xavier' */
  if (GetAt(original, 0) == 'X') {
    primary += "S";    /* 'Z' maps to 'S' */
    secondary += "S";
    current += 1;
  }

  /* main loop */
  while ((primary.length() < max_length) || (secondary.length() < max_length)) {
    if (current >= length) {
      break;
    }

    switch (GetAt(original, current)) {
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
    case 'Y':
      if (current == 0) {
        /* all init vowels now map to 'A' */
        primary += "A";
        secondary += "A";
      }
      current += 1;
      break;

    case 'B':
      /* "-mb", e.g", "dumb", already skipped over... */
      primary += "P";
      secondary += "P";

      if (GetAt(original, current + 1) == 'B')
        current += 2;
      else
        current += 1;
      break;

    case macroman_Ç:
      primary += "S";
      secondary += "S";
      current += 1;
      break;

    case 'C':
      /* various germanic */
      if ((current > 1) &&
          !IsVowel(original, current - 2) &&
          StringAt(original, (current - 1), 3, "ACH", "") &&
          ((GetAt(original, current + 2) != 'I') &&
           ((GetAt(original, current + 2) != 'E') ||
            StringAt(original, (current - 2), 6, "BACHER", "MACHER", "")))) {
        primary += "K";
        secondary += "K";
        current += 2;
        break;
      }

      /* special case 'caesar' */
      if ((current == 0) && StringAt(original, current, 6, "CAESAR", "")) {
        primary += "S";
        secondary += "S";
        current += 2;
        break;
      }

      /* italian 'chianti' */
      if (StringAt(original, current, 4, "CHIA", "")) {
        primary += "K";
        secondary += "K";
        current += 2;
        break;
      }

      if (StringAt(original, current, 2, "CH", "")) {
        /* find 'michael' */
        if ((current > 0) && StringAt(original, current, 4, "CHAE", "")) {
          primary += "K";
          secondary += "X";
          current += 2;
          break;
        }

        /* greek roots e.g. 'chemistry', 'chorus' */
        if ((current == 0) &&
            (StringAt(original, (current + 1), 5,
                      "HARAC", "HARIS", "") ||
             StringAt(original, (current + 1), 3,
                      "HOR", "HYM", "HIA", "HEM", "")) &&
            !StringAt(original, 0, 5, "CHORE", "")) {
          primary += "K";
          secondary += "K";
          current += 2;
          break;
        }

        /* germanic, greek, or otherwise 'ch' for 'kh' sound */
        if ((StringAt(original, 0, 4, "VAN ", "VON ", "") ||
             StringAt(original, 0, 3, "SCH", "")) ||
            /*  'architect but not 'arch', 'orchestra', 'orchid' */
            StringAt(original, (current - 2), 6,
                     "ORCHES", "ARCHIT", "ORCHID", "") ||
            StringAt(original, (current + 2), 1,
                     "T", "S", "") ||
            ((StringAt(original, (current - 1), 1,
                       "A", "O", "U", "E", "") ||
              (current == 0)) &&
             /* e.g., 'wachtler', 'wechsler', but not 'tichner' */
             StringAt(original, (current + 2), 1, "L", "R",
                      "N", "M", "B", "H", "F", "V", "W", " ", ""))) {
          primary += "K";
          secondary += "K";
        } else {
          if (current > 0) {
            if (StringAt(original, 0, 2, "MC", "")) {
              /* e.g., "McHugh" */
              primary += "K";
              secondary += "K";
            } else {
              primary += "X";
              secondary += "K";
            }
          } else {
            primary += "X";
            secondary += "X";
          }
        }
        current += 2;
        break;
      }
      /* e.g, 'czerny' */
      if (StringAt(original, current, 2, "CZ", "") &&
          !StringAt(original, (current - 2), 4, "WICZ", "")) {
        primary += "S";
        secondary += "X";
        current += 2;
        break;
      }

      /* e.g., 'focaccia' */
      if (StringAt(original, (current + 1), 3, "CIA", "")) {
        primary += "X";
        secondary += "X";
        current += 3;
        break;
      }

      /* double 'C', but not if e.g. 'McClellan' */
      if (StringAt(original, current, 2, "CC", "") &&
          !((current == 1) && (GetAt(original, 0) == 'M'))) {
        /* 'bellocchio' but not 'bacchus' */
        if (StringAt(original, (current + 2), 1, "I", "E", "H", "") &&
            !StringAt(original, (current + 2), 2, "HU", "")) {
          /* 'accident', 'accede' 'succeed' */
          if (((current == 1) && (GetAt(original, current - 1) == 'A')) ||
              StringAt(original, (current - 1), 5, "UCCEE", "UCCES", "")) {
            primary += "KS";
            secondary += "KS";
            /* 'bacci', 'bertucci', other italian */
          } else {
            primary += "X";
            secondary += "X";
          }
          current += 3;
          break;
        } else {  /* Pierce's rule */
          primary += "K";
          secondary += "K";
          current += 2;
          break;
        }
      }

      if (StringAt(original, current, 2, "CK", "CG", "CQ", "")) {
        primary += "K";
        secondary += "K";
        current += 2;
        break;
      }

      if (StringAt(original, current, 2, "CI", "CE", "CY", "")) {
        /* italian vs. english */
        if (StringAt(original, current, 3, "CIO", "CIE", "CIA", "")) {
          primary += "S";
          secondary += "X";
        } else {
          primary += "S";
          secondary += "S";
        }
        current += 2;
        break;
      }

      /* else */
      primary += "K";
      secondary += "K";

      /* name sent in 'mac caffrey', 'mac gregor */
      if (StringAt(original, (current + 1), 2, " C", " Q", " G", ""))
        current += 3;
      else
        if (StringAt(original, (current + 1), 1, "C", "K", "Q", "") &&
            !StringAt(original, (current + 1), 2, "CE", "CI", ""))
          current += 2;
        else
          current += 1;
      break;

    case 'D':
      if (StringAt(original, current, 2, "DG", "")) {
        if (StringAt(original, (current + 2), 1, "I", "E", "Y", "")) {
          /* e.g. 'edge' */
          primary += "J";
          secondary += "J";
          current += 3;
          break;
        } else {
          /* e.g. 'edgar' */
          primary += "TK";
          secondary += "TK";
          current += 2;
          break;
        }
      }

      if (StringAt(original, current, 2, "DT", "DD", "")) {
        primary += "T";
        secondary += "T";
        current += 2;
        break;
      }

      /* else */
      primary += "T";
      secondary += "T";
      current += 1;
      break;

    case 'F':
      if (GetAt(original, current + 1) == 'F')
        current += 2;
      else
        current += 1;
      primary += "F";
      secondary += "F";
      break;

    case 'G':
      if (GetAt(original, current + 1) == 'H') {
        if ((current > 0) && !IsVowel(original, current - 1)) {
          primary += "K";
          secondary += "K";
          current += 2;
          break;
        }

        if (current < 3) {
          /* 'ghislane', ghiradelli */
          if (current == 0) {
            if (GetAt(original, current + 2) == 'I') {
              primary += "J";
              secondary += "J";
            } else {
              primary += "K";
              secondary += "K";
            }
            current += 2;
            break;
          }
        }
        /* Parker's rule (with some further refinements) - e.g., 'hugh' */
        if (((current > 1) &&
             StringAt(original, (current - 2), 1, "B", "H", "D", "")) ||
            /* e.g., 'bough' */
            ((current > 2) &&
             StringAt(original, (current - 3), 1, "B", "H", "D", "")) ||
            /* e.g., 'broughton' */
            ((current > 3) &&
             StringAt(original, (current - 4), 1, "B", "H", ""))) {
          current += 2;
          break;
        } else {
          /* e.g., 'laugh', 'McLaughlin', 'cough', 'gough', 'rough', 'tough' */
          if ((current > 2) &&
              (GetAt(original, current - 1) == 'U') &&
              StringAt(original, (current - 3), 1, "C",
                       "G", "L", "R", "T", "")) {
            primary += "F";
            secondary += "F";
          } else if ((current > 0) &&
                     GetAt(original, current - 1) != 'I') {
            primary += "K";
            secondary += "K";
          }

          current += 2;
          break;
        }
      }

      if (GetAt(original, current + 1) == 'N') {
        if ((current == 1) &&
            IsVowel(original, 0) &&
            !SlavoGermanic(original)) {
          primary += "KN";
          secondary += "N";
        } else
          /* not e.g. 'cagney' */
          if (!StringAt(original, (current + 2), 2, "EY", "") &&
              (GetAt(original, current + 1) != 'Y') &&
              !SlavoGermanic(original)) {
            primary += "N";
            secondary += "KN";
          } else {
            primary += "KN";
            secondary += "KN";
          }
        current += 2;
        break;
      }

      /* 'tagliaro' */
      if (StringAt(original, (current + 1), 2, "LI", "") &&
          !SlavoGermanic(original)) {
        primary += "KL";
        secondary += "L";
        current += 2;
        break;
      }

      /* -ges-,-gep-,-gel-, -gie- at beginning */
      if ((current == 0) &&
          ((GetAt(original, current + 1) == 'Y') ||
           StringAt(original, (current + 1), 2, "ES", "EP",
                    "EB", "EL", "EY", "IB", "IL", "IN", "IE",
                    "EI", "ER", ""))) {
        primary += "K";
        secondary += "J";
        current += 2;
        break;
      }

      /*  -ger-,  -gy- */
      if ((StringAt(original, (current + 1), 2, "ER", "") ||
           (GetAt(original, current + 1) == 'Y')) &&
          !StringAt(original, 0, 6, "DANGER", "RANGER", "MANGER", "") &&
          !StringAt(original, (current - 1), 1, "E", "I", "") &&
          !StringAt(original, (current - 1), 3, "RGY", "OGY", "")) {
        primary += "K";
        secondary += "J";
        current += 2;
        break;
      }

      /*  italian e.g, 'biaggi' */
      if (StringAt(original, (current + 1), 1, "E", "I", "Y", "") ||
          StringAt(original, (current - 1), 4, "AGGI", "OGGI", "")) {
        /* obvious germanic */
        if ((StringAt(original, 0, 4, "VAN ", "VON ", "") ||
             StringAt(original, 0, 3, "SCH", "")) ||
            StringAt(original, (current + 1), 2, "ET", ""))
          {
            primary += "K";
            secondary += "K";
          } else {
          /* always soft if french ending */
          if (StringAt(original, (current + 1), 4, "IER ", "")) {
            primary += "J";
            secondary += "J";
          } else {
            primary += "J";
            secondary += "K";
          }
        }
        current += 2;
        break;
      }

      if (GetAt(original, current + 1) == 'G')
        current += 2;
      else
        current += 1;
      primary += "K";
      secondary += "K";
      break;

    case 'H':
      /* only keep if first & before vowel or btw. 2 vowels */
      if (((current == 0) ||
           IsVowel(original, current - 1)) &&
          IsVowel(original, current + 1)) {
        primary += "H";
        secondary += "H";
        current += 2;
      }
      else        /* also takes care of 'HH' */
        current += 1;
      break;

    case 'J':
      /* obvious spanish, 'jose', 'san jacinto' */
      if (StringAt(original, current, 4, "JOSE", "") ||
          StringAt(original, 0, 4, "SAN ", "")) {
        if (((current == 0) && (GetAt(original, current + 4) == ' ')) ||
            StringAt(original, 0, 4, "SAN ", "")) {
          primary += "H";
          secondary += "H";
        } else {
          primary += "J";
          secondary += "H";
        }
        current += 1;
        break;
      }

      if ((current == 0) && !StringAt(original, current, 4, "JOSE", "")) {
        primary += "J";    /* Yankelovich/Jankelowicz */
        secondary += "A";
      } else {
        /* spanish pron. of e.g. 'bajador' */
        if (IsVowel(original, current - 1) &&
            !SlavoGermanic(original) &&
            ((GetAt(original, current + 1) == 'A') ||
             (GetAt(original, current + 1) == 'O'))) {
          primary += "J";
          secondary += "H";
        } else {
          if (current == last) {
            primary += "J";
            secondary += "";
          } else {
            if (!StringAt(original, (current + 1), 1,
                          "L", "T", "K", "S", "N", "M", "B", "Z", "") &&
                !StringAt(original, (current - 1), 1, "S", "K", "L", "")) {
              primary += "J";
              secondary += "J";
            }
          }
        }
      }

      if (GetAt(original, current + 1) == 'J')    /* it could happen! */
        current += 2;
      else
        current += 1;
      break;

    case 'K':
      if (GetAt(original, current + 1) == 'K')
        current += 2;
      else
        current += 1;
      primary += "K";
      secondary += "K";
      break;

    case 'L':
      if (GetAt(original, current + 1) == 'L') {
        /* spanish e.g. 'cabrillo', 'gallegos' */
        if (((current == (length - 3)) &&
             StringAt(original, (current - 1), 4,
                      "ILLO", "ILLA", "ALLE", "")) ||
            ((StringAt(original, (last - 1), 2, "AS", "OS", "") ||
              StringAt(original, last, 1, "A", "O", "")) &&
             StringAt(original, (current - 1), 4, "ALLE", ""))) {
          primary += "L";
          secondary += "";
          current += 2;
          break;
        }
        current += 2;
      }
      else
        current += 1;
      primary += "L";
      secondary += "L";
      break;

    case 'M':
      if ((StringAt(original, (current - 1), 3, "UMB", "") &&
           (((current + 1) == last) ||
            StringAt(original, (current + 2), 2, "ER", ""))) ||
          /* 'dumb','thumb' */
          (GetAt(original, current + 1) == 'M')) {
        current += 2;
      } else {
        current += 1;
      }
      primary += "M";
      secondary += "M";
      break;

    case 'N':
      if (GetAt(original, current + 1) == 'N') {
        current += 2;
      } else {
        current += 1;
      }
      primary += "N";
      secondary += "N";
      break;

    case macroman_Ñ:
      current += 1;
      primary += "N";
      secondary += "N";
      break;

    case 'P':
      if (GetAt(original, current + 1) == 'H') {
        primary += "F";
        secondary += "F";
        current += 2;
        break;
      }

      /* also account for "campbell", "raspberry" */
      if (StringAt(original, (current + 1), 1, "P", "B", ""))
        current += 2;
      else
        current += 1;
      primary += "P";
      secondary += "P";
      break;

    case 'Q':
      if (GetAt(original, current + 1) == 'Q')
        current += 2;
      else
        current += 1;
      primary += "K";
      secondary += "K";
      break;

    case 'R':
      /* french e.g. 'rogier', but exclude 'hochmeier' */
      if ((current == last) &&
          !SlavoGermanic(original) &&
          StringAt(original, (current - 2), 2, "IE", "") &&
          !StringAt(original, (current - 4), 2, "ME", "MA", "")) {
        primary += "";
        secondary += "R";
      } else {
        primary += "R";
        secondary += "R";
      }

      if (GetAt(original, current + 1) == 'R')
        current += 2;
      else
        current += 1;
      break;

    case 'S':
      /* special cases 'island', 'isle', 'carlisle', 'carlysle' */
      if (StringAt(original, (current - 1), 3, "ISL", "YSL", "")) {
        current += 1;
        break;
      }

      /* special case 'sugar-' */
      if ((current == 0) && StringAt(original, current, 5, "SUGAR", "")) {
        primary += "X";
        secondary += "S";
        current += 1;
        break;
      }

      if (StringAt(original, current, 2, "SH", "")) {
        /* germanic */
        if (StringAt(original, (current + 1), 4,
                     "HEIM", "HOEK", "HOLM", "HOLZ", "")) {
          primary += "S";
          secondary += "S";
        } else {
          primary += "X";
          secondary += "X";
        }
        current += 2;
        break;
      }

      /* italian & armenian */
      if (StringAt(original, current, 3, "SIO", "SIA", "") ||
          StringAt(original, current, 4, "SIAN", "")) {
        if (!SlavoGermanic(original)) {
          primary += "S";
          secondary += "X";
        } else {
          primary += "S";
          secondary += "S";
        }
        current += 3;
        break;
      }

      /* german & anglicisations, e.g. 'smith' match 'schmidt', 'snider' match 'schneider'
         also, -sz- in slavic language altho in hungarian it is pronounced 's' */
      if (((current == 0) &&
           StringAt(original, (current + 1), 1, "M", "N", "L", "W", "")) ||
          StringAt(original, (current + 1), 1, "Z", "")) {
        primary += "S";
        secondary += "X";
        if (StringAt(original, (current + 1), 1, "Z", ""))
          current += 2;
        else
          current += 1;
        break;
      }

      if (StringAt(original, current, 2, "SC", "")) {
        /* Schlesinger's rule */
        if (GetAt(original, current + 2) == 'H') {
          /* dutch origin, e.g. 'school', 'schooner' */
          if (StringAt(original, (current + 3), 2,
                       "OO", "ER", "EN", "UY", "ED", "EM", "")) {
            /* 'schermerhorn', 'schenker' */
            if (StringAt(original, (current + 3), 2, "ER", "EN", "")) {
              primary += "X";
              secondary += "SK";
            } else {
              primary += "SK";
              secondary += "SK";
            }
            current += 3;
            break;
          } else {
            if ((current == 0) && !IsVowel(original, 3) &&
                (GetAt(original, 3) != 'W')) {
              primary += "X";
              secondary += "S";
            } else {
              primary += "X";
              secondary += "X";
            }
            current += 3;
            break;
          }
        }

        if (StringAt(original, (current + 2), 1, "I", "E", "Y", "")) {
          primary += "S";
          secondary += "S";
          current += 3;
          break;
        }
        /* else */
        primary += "SK";
        secondary += "SK";
        current += 3;
        break;
      }

      /* french e.g. 'resnais', 'artois' */
      if ((current == last) &&
          StringAt(original, (current - 2), 2, "AI", "OI", "")) {
        primary += "";
        secondary += "S";
      } else {
        primary += "S";
        secondary += "S";
      }

      if (StringAt(original, (current + 1), 1, "S", "Z", ""))
        current += 2;
      else
        current += 1;
      break;

    case 'T':
      if (StringAt(original, current, 4, "TION", "")) {
        primary += "X";
        secondary += "X";
        current += 3;
        break;
      }

      if (StringAt(original, current, 3, "TIA", "TCH", "")) {
        primary += "X";
        secondary += "X";
        current += 3;
        break;
      }

      if (StringAt(original, current, 2, "TH", "") ||
          StringAt(original, current, 3, "TTH", "")) {
        /* special case 'thomas', 'thames' or germanic */
        if (StringAt(original, (current + 2), 2, "OM", "AM", "") ||
            StringAt(original, 0, 4, "VAN ", "VON ", "") ||
            StringAt(original, 0, 3, "SCH", "")) {
          primary += "T";
          secondary += "T";
        } else {
          primary += "0"; /* yes, zero */
          secondary += "T";
        }
        current += 2;
        break;
      }

      if (StringAt(original, (current + 1), 1, "T", "D", "")) {
        current += 2;
      } else {
        current += 1;
      }
      primary += "T";
      secondary += "T";
      break;

    case 'V':
      if (GetAt(original, current + 1) == 'V') {
        current += 2;
      } else {
        current += 1;
      }
      primary += "F";
      secondary += "F";
      break;

    case 'W':
      /* can also be in middle of word */
      if (StringAt(original, current, 2, "WR", "")) {
        primary += "R";
        secondary += "R";
        current += 2;
        break;
      }

      if ((current == 0) &&
          (IsVowel(original, current + 1) ||
           StringAt(original, current, 2, "WH", ""))) {
        /* Wasserman should match Vasserman */
        if (IsVowel(original, current + 1)) {
          primary += "A";
          secondary += "F";
        } else {
          /* need Uomo to match Womo */
          primary += "A";
          secondary += "A";
        }
      }

      /* Arnow should match Arnoff */
      if (((current == last) && IsVowel(original, current - 1)) ||
          StringAt(original, (current - 1), 5,
                   "EWSKI", "EWSKY", "OWSKI", "OWSKY", "") ||
          StringAt(original, 0, 3, "SCH", "")) {
        primary += "";
        secondary += "F";
        current += 1;
        break;
      }

      /* polish e.g. 'filipowicz' */
      if (StringAt(original, current, 4, "WICZ", "WITZ", "")) {
        primary += "TS";
        secondary += "FX";
        current += 4;
        break;
      }

      /* else skip it */
      current += 1;
      break;

    case 'X':
      /* french e.g. breaux */
      if (!((current == last) &&
            (StringAt(original, (current - 3), 3, "IAU", "EAU", "") ||
             StringAt(original, (current - 2), 2, "AU", "OU", "")))) {
        primary += "KS";
        secondary += "KS";
      }


      if (StringAt(original, (current + 1), 1, "C", "X", ""))
        current += 2;
      else
        current += 1;
      break;

    case 'Z':
      /* chinese pinyin e.g. 'zhao' */
      if (GetAt(original, current + 1) == 'H') {
        primary += "J";
        secondary += "J";
        current += 2;
        break;
      } else if (StringAt(original, (current + 1), 2, "ZO", "ZI", "ZA", "") ||
                 (SlavoGermanic(original) &&
                  ((current > 0) &&
                   GetAt(original, current - 1) != 'T'))) {
        primary += "S";
        secondary += "TS";
      } else {
        primary += "S";
        secondary += "S";
      }

      if (GetAt(original, current + 1) == 'Z')
        current += 2;
      else
        current += 1;
      break;

    default:
      current += 1;
    }
    /* printf("PRIMARY: %s\n", primary.str);
       printf("SECONDARY: %s\n", secondary.str);  */
  }

  if (primary.length() > max_length)
    SetAt(primary, max_length, '\0');

  if (secondary.length() > max_length)
    SetAt(secondary, max_length, '\0');

  push_back(codes, primary);
  push_back(codes, secondary);
}

static void u16_to_macroman(PA_Unistring *word, std::string& word_macroman) {
    
    uint32_t len = (uint32_t)(word->fLength * 4) + sizeof(uint8_t);
    std::vector<uint8_t> buf(len);
    
    PA_ConvertCharsetToCharset(
                               (char *)word->fString,
                               word->fLength * sizeof(PA_Unichar),
                               eVTC_UTF_16,
                               (char *)&buf[0],
                               len,
                               eVTC_MAC_ROMAN
                               );
    
    word_macroman = std::string((const char *)&buf[0]);
}

static void DoubleMetaphone(PA_PluginParameters params) {

    PA_CollectionRef metaphones = PA_CreateCollection();

    PA_Unistring *word = PA_GetStringParameter(params, 1);
            
    std::string word_macroman;
    
    u16_to_macroman(word, word_macroman);
    
    DoubleMetaphoneImplementation(word_macroman, metaphones);
    
    PA_ReturnCollection(params, metaphones);
}

